# ============================================
# CCP -> psPAS (no prompts) -> Safe Membership Report
# ============================================
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
$ProgressPreference = 'SilentlyContinue'

# -------- Config --------
# CCP (AIMWebService) to fetch the service user for Identity auth
$CCPAddress  = "https://vskau1p1231.cna.com"
$location    = "AIMWebService"
$application = "PAMDiscovery"
$safe        = "CA_PCloud_Admins"
$object      = "cna.com-CA_PAMDiscovery_SVC"

# Identity / Privilege Cloud
$IdentityTenantURL = "aat4012.id.cyberark.cloud"
$PCloudSubdomain   = "cna-prod"

# Output paths
$CsvFilePath = "E:\Installation Media\RemovePendingAccount\SafeMemberReport.csv"
$LogFile     = "E:\Installation Media\RemovePendingAccount\SafeMemberReportLog.txt"
New-Item -ItemType File -Force -Path $LogFile | Out-Null

function Write-Log([string]$Message, [ConsoleColor]$Color='White') {
    $ts = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $line = "$ts - $Message"
    Write-Host $line -ForegroundColor $Color
    Add-Content -Path $LogFile -Value $line
}

# -------- Retrieve service credential from CCP (no prompt) --------
$ccpUrl = "$CCPAddress/$location/api/Accounts?AppID=$application&Safe=$safe&Object=$object"
Write-Log "Fetching CCP credential: AppID=$application, Safe=$safe, Object=$object" Cyan

try {
    $resp = Invoke-RestMethod -Uri $ccpUrl -Method GET -Headers @{ 'Content-Type'='application/json' }
    if (-not $resp -or -not $resp.Username -or -not $resp.Content) { throw "Missing Username/Content in CCP response." }
    Write-Log "CCP returned username '$($resp.Username)'." Green
} catch {
    Write-Log "ERROR: CCP credential fetch failed: $($_.Exception.Message)" Red
    throw
}

# Build PSCredential (no user prompt)
$secPwd = ConvertTo-SecureString -String $resp.Content -AsPlainText -Force
$UPCred = New-Object System.Management.Automation.PSCredential ($resp.Username, $secPwd)

# -------- psPAS auth via Identity header --------
Import-Module psPAS -ErrorAction Stop
Write-Log "Requesting Identity header for '$IdentityTenantURL' (subdomain '$PCloudSubdomain')." Cyan

try {
    $header = Get-IdentityHeader -IdentityTenantURL $IdentityTenantURL -psPASFormat -PCloudSubdomain $PCloudSubdomain -UPCreds $UPCred
    Use-PASSession $header
    $session = Get-PASSession
    if (-not $session) { throw "PAS session object is null." }
    Write-Log "‚úÖ Authentication successful, PAS session established." Green
} catch {
    Write-Log "‚ùå Authentication failed: $($_.Exception.Message)" Red
    exit 1
}

# -------- Retrieve Safes --------
Write-Log "Retrieving list of Safes..." Yellow
try {
    $Safes = Get-PASSafe
    Write-Log "‚úÖ Retrieved $($Safes.Count) Safes." Green
} catch {
    Write-Log "‚ùå ERROR: Failed to retrieve Safes - $($_.Exception.Message)" Red
    exit 1
}

# -------- Retrieve Safe Members & Permissions --------
$SafeMembersReport = New-Object System.Collections.Generic.List[object]

foreach ($SafeItem in $Safes) {
    $SafeName = $SafeItem.safeName
    Write-Log "üîπ Retrieving members for Safe: $SafeName" Cyan

    try {
        $Members = Get-PASSafeMember -SafeName $SafeName -ErrorAction Stop

        # Normalize to array
        if ($null -eq $Members) { $Members = @() }
        elseif ($Members -isnot [System.Collections.IEnumerable]) { $Members = @($Members) }

        if ($Members.Count -eq 0) {
            Write-Log "‚ö†Ô∏è No members found for Safe: $SafeName" Yellow
        }

        foreach ($Member in $Members) {
            # Guard against null Permissions object
            $perm = $Member.Permissions
            $SafeMembersReport.Add([PSCustomObject]@{
                SafeName                                 = $SafeName
                Member                                   = $Member.MemberName
                MemberType                               = $Member.MemberType
                UseAccounts                              = $perm.useAccounts
                RetrieveAccounts                         = $perm.retrieveAccounts
                ListAccounts                             = $perm.listAccounts
                AddAccounts                              = $perm.addAccounts
                UpdateAccountContent                     = $perm.updateAccountContent
                UpdateAccountProperties                  = $perm.updateAccountProperties
                InitiateCPMAccountManagementOperations   = $perm.initiateCPMAccountManagementOperations
                SpecifyNextAccountContent                = $perm.specifyNextAccountContent
                RenameAccounts                           = $perm.renameAccounts
                DeleteAccounts                           = $perm.deleteAccounts
                UnlockAccounts                           = $perm.unlockAccounts
                ManageSafe                               = $perm.manageSafe
                ManageSafeMembers                        = $perm.manageSafeMembers
                BackupSafe                               = $perm.backupSafe
                ViewAuditLog                             = $perm.viewAuditLog
                ViewSafeMembers                          = $perm.viewSafeMembers
                AccessWithoutConfirmation                = $perm.accessWithoutConfirmation
                CreateFolders                            = $perm.createFolders
                DeleteFolders                            = $perm.deleteFolders
                MoveAccountsAndFolders                   = $perm.moveAccountsAndFolders
                RequestsAuthorizationLevel1              = $perm.requestsAuthorizationLevel1
                RequestsAuthorizationLevel2              = $perm.requestsAuthorizationLevel2
            })
        }
        Write-Log "‚úÖ Retrieved $($Members.Count) member entries for Safe: $SafeName" Green
    } catch {
        Write-Log "‚ùå ERROR: Failed to retrieve members for Safe '$SafeName' - $($_.Exception.Message)" Red
    }
}

# -------- Export to CSV --------
# Ensure directory exists
$dir = Split-Path -Path $CsvFilePath -Parent
if (-not (Test-Path $dir)) { New-Item -ItemType Directory -Path $dir -Force | Out-Null }

try {
    $SafeMembersReport | Export-Csv -Path $CsvFilePath -NoTypeInformation -Encoding UTF8
    Write-Log "‚úÖ Safe Member Report successfully exported to: $CsvFilePath" Green
    Write-Log "üîπ Safe Member Report generation completed." Green
} catch {
    Write-Log "‚ùå ERROR: Failed to export CSV - $($_.Exception.Message)" Red
    exit 1
}
